# 수리공 항승

## 문제
항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. </br>
항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다. </br>
파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다. </br>
항승이는 길이가 L인 테이프를 무한개 가지고 있다. </br>
항승이는 테이프를 이용해서 물을 막으려고 한다. </br>
항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다. </br>
물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때,  </br>
항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오.  </br>
테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다. </br>

## 입력
첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다. </br>
둘째 줄에는 물이 새는 곳의 위치가 주어진다. N과 L은 1,000보다 작거나 같은 자연수이고, </br>
물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다. </br>

## 출력
첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다.

## 풀이
정렬문제 보단 그리디 수학 문제 느낌이었다. </br>
숫자는 왜이리 안익숙해지는지.. </br>

처음 접근은 이전 위치와 현재 위치 비교해서 </br>
테이프 길이보다 거리가 가까우면 테이프 하나로 처리하는 방법을 사용했다. </br>
접근을 p-temp >= L 로 줬었는데, 이렇게 되면 좌우 0.5씩 커버가 안된다. </br>
누수 위치 1.4 이고 테이프길이 3일때 4-1하면 3이므로 막을수 있다 도출한다. </br>
하지만 실제론 4.5까지 막아 줘야하므로 테이프 하나가 더 필요하다. </br>

그래서 조건을 p - temp > L - 1 로 바꾸었다. </br>
누수길이 0.5씩 더 필요하므로 필요길이에서 1을 뺴준거다. </br>
이식을 좀더 보기 쉽게하면  temp+L-1 < p 가 된다. </br>

```python
N, L = map(int,input().split())
point = list(map(int,input().split()))
point.sort()

#print(N,L,point)
count = 0
temp = -float('inf')
for p in point:
  #print('t p',temp, p)

  #if (p - temp) + 0.5 >= L:
  if temp + L -1 < p:
    #print('테이프')
    count+=1      
    temp = p

print(count)
```
 </br>
수식 문제 풀때 하나씩 대입하면서 고치고있는데.. 좀 더 생각하며 풀어야할것 같다.

좀 더 깔끔한 코드로는 이전 포인트랑 비교하는게 아닌 </br>
현재 테이프가 커버가능한 마지막 위치를 추적하는 방식도 있다. </br>

```python
N, L = map(int,input().split())
point = list(map(int,input().split()))
point.sort()

#print(N,L,point)
count = 0
end = 0.0
for p in point:
  #print('t p',temp, p)
  
  if p > end:
    #print('테이프')
    end = p + L - 0.5
    count+=1      
    
print(count)
```
