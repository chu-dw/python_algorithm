# 너구리 구구

## 문제
텔레토비 동산에 사는 너구리 구구는 입구, 거실, 주방, 안방, 공부방, 운동실, 음악실, 음식 창고 등 N개의 방을 가지고 있다.  </br>
입구를 포함한 모든 방은 1부터 N까지의 번호가 있고, 입구는 1번이다.   </br>
구구의 집으로 들어가는 입구는 한 개이며 입구과 모든 방들은 총 N-1개의 길로 서로 오고 갈 수 있다. </br>
구구는 스머프 동산에서 멜론아 아이스크림을 발견했다.  </br>
구구는 무더운 여름 햇살을 피해 최대한 입구에서 먼 방에 아이스크림을 숨기려고 한다. </br>
구구가 집 입구에서 멜론아 아이스크림을 숨기려고 하는 방까지 이동하는 거리를 구하여라. </br>

## 입력
첫째 줄에 정수 N(1 ≤ N ≤ 5,000)이 주어진다. </br>
다음 N-1개의 줄에 구구의 집의 모든 길의 정보가 정수 A, B, C(1 ≤ A, B ≤ N, 1 ≤ C ≤ 1,000,000,000)로 주어진다. </br>
A번 방과 B번 방 사이를 양방향으로 연결하는 길의 길이가 C임을 의미한다. </br>

## 출력
구구가 집 입구에서 멜론아 아이스크림을 숨기려고 하는 방까지 이동하는 거리를 구하여라. </br>

## 풀이
기본적인 dfs문제이다.
처음 코드도 정답 처리는 됐지만 최대거리를 구하는 위치를 수정해줬다. </br>
처음에는 stack에 넣어주면서 거리 최대값을 구했는데 </br>
이럴경우 스택에는 들어갔지만 그다음 visited 조건문에서 걸려 사용이 안될수도 있다. </br>
stack에서 꺼낸다음 visited조건 돌리고 최대값을 계산 해주었다. </br>
아래는 제귀를 사용해서도 풀어보았다.  </br>

```python
import sys
from collections import deque

N = int(input())
visited = [False]*(N+1)

rooms = [[] for _ in range(N+1)]

for i in range(N-1):
  A,B,C = map(int, sys.stdin.readline().split())
  rooms[A].append((B,C))
  rooms[B].append((A,C))


print(rooms)

max_dis = 0

def dfs(rooms, start, val):
  stack = deque([(start, val)])
  global max_dis
   
  
  while stack:
    node, val = stack.pop()
    
    print(visited)
    if visited[node]:      
      continue

    print('nv',node, val)
    visited[node] = True

    max_dis = max(val, max_dis)

    for next_node, value in rooms[node]:
      print('nv', next_node, value)
      if not visited[next_node]:           
        stack.append((next_node, val+value))
        print('val', stack)
        # max_dis = max(val + value, max_dis)

  return max_dis
  
result = dfs(rooms,1, 0)
print(result)
```

