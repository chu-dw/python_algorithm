# 침투

## 문제
인제대학교 생화학연구실에 재직중인 석교수는 전류가 침투(percolate) 할 수 있는 섬유 물질을 개발하고 있다. </br>
이 섬유 물질은 2차원 M × N 격자로 표현될 수 있다.  </br>
편의상 2차원 격자의 위쪽을 바깥쪽(outer side), 아래쪽을 안쪽(inner side)라고 생각하기로 한다. </br>
또한 각 격자는 검은색 아니면 흰색인데,  </br>
검은색은 전류를 차단하는 물질임을 뜻하고 흰색은 전류가 통할 수 있는 물질임을 뜻한다.  </br>
전류는 섬유 물질의 가장 바깥쪽 흰색 격자들에 공급되고, 이후에는 상하좌우로 인접한 흰색 격자들로 전달될 수 있다. </br>
김 교수가 개발한 섬유 물질을 나타내는 정보가 2차원 격자 형태로 주어질 때, </br>
바깥쪽에서 흘려 준 전류가 안쪽까지 침투될 수 있는지 아닌지를 판단하는 프로그램을 작성하시오 </br>

## 입력
첫째 줄에는 격자의 크기를 나타내는  M (2 ≤ M ≤ 1,000) 과 N (2 ≤ N ≤ 1,000) 이 주어진다. </br>
M줄에 걸쳐서, N개의 0 또는 1 이 공백 없이 주어진다. </br>
0은 전류가 잘 통하는 흰색, 1은 전류가 통하지 않는 검은색 격자임을 뜻한다. </br>

## 출력
바깥에서 흘려준 전류가 안쪽까지 잘 전달되면 YES를 출력한다. </br>
그렇지 않으면 NO를 출력한다. </br>

## 풀이
역시 꾸준히 해야한다.. 다시 초기화된 느낌... </br>
재귀를 사용한 dfs로 접근했다 </br>
0번 열에 있는 0들에서 dfs출발하여 M번째까지 0이 도착하면 끝내는 방식이다. </br>
조금 어거지로 연결시키다 보니 잘 안됐다. </br>
리턴을 생각하기 조금 귀찮아서 yes를 exit로 끝내버리고 </br>
no 추적을 하려했는데 잘 안되었다. </br>
```python
M, N = map(int, input().split())

maps = []
dx = [0,0,-1,1]
dy = [-1,1,0,0]

visited = [[False]*(M+1) for _ in range(N+1)]
#print(visited)

for _ in range(N):
  maps.append(list(map(int, input())))
    
#print(maps)
check_yes = False

def dfs(x, y, vidited):

    for i in range(4):
        n_x = x + dx[i]
        n_y = y + dy[i]
        
        if 0 <= n_x < M and 0 <= n_y < N:
            if not visited[n_x][n_y] and maps[n_x][n_y] ==0:
                #print('현재노드', n_x, n_y, maps[n_x][n_y])
                if n_x == N-1:
                    print("YES")                    
                    exit()
                visited[n_x][n_y] = True
                dfs(n_x,n_y,vidited)
    return 0
    
for i in range(M):
    dfs(0,i,visited)

print("NO")
```

결국 또 범위 문제였다. 항상 헷갈리는거 같다 2차원 배열 사용할땐 maps[row][col] 이다.  </br>
(0,0) (0,1) .. </br>
(1.0)  .. </br>
이런식이기 때문에 일반적으로 (x,y) 순서로 쓰면 x가 세로  y가 가로 값을 나타낸다. </br>
이걸 잘 생각해서 다시 해보면 </br>
```python
import sys
sys.setrecursionlimit(10**6)

M,N = map(int,input().split())
maps=[]

dy = [-1,1,0,0]
dx = [0,0,-1,1]

# maps[M][N]

for _ in range(M):
    maps.append(list(map(int,sys.stdin.readline().strip())))
    
#print(maps)

visited = [[False]*N for _ in range(M)]

def dfs(x, y, visited):
    visited[x][y] = True
    #print(x, y)
    if x == M-1:
        print("YES")
        sys.exit()

    for i in range(4):
        m_x = x + dx[i]
        n_y = y + dy[i]
        # m x 랑 짝 m높이니까 x가 높이 이렇게 생각?

        if 0 <= m_x < M and 0 <= n_y < N:
            if not visited[m_x][n_y] and maps[m_x][n_y] == 0:
                dfs(m_x, n_y, visited)

for i in range(N):
    dfs(0,i,visited)

print("NO")
```
x는 새로니까 새로 값인 M과, y는 가로니까 가로값인 N과 묶어줬다.
이렇게 해놓으니 덜 헷갈리는 거 같다. </br>

이렇게 풀었지만 결국 이문제는 bfs가 더 적합한 문제였다. 
한번 쭉 내려와서 찾으면 끝나버리니까 dfs로 접근한 것이였는데 </br>
수가 많아 질수록 아닌 길도 계속 깊게 들어가게 된다. 그래서 안정적인 bfs가 더 적합하다고 한다. </br>
dfs쓰는 문제가 너무 적어서.. 아직 구분이 잘 안되는거 같다. </br>

일단 bfs로도 풀어보았다. </br>
확실히 bfs는 많이 풀어봐서 바로 성공했다.
```python
import sys
from collections import deque

# M 세로, N 가로

M,N = map(int, input().split())
maps=[]

dy = [-1,1,0,0]
dx = [0,0,-1,1]

visited = [[False]*N for _ in range(M)]

for _ in range(M):
    maps.append(list(map(int,sys.stdin.readline().strip())))

def bfs(x,y,visited):
    queue = deque([(x,y)])
    visited[x][y] = True

    while queue:
        x,y = queue.popleft()
        
        if x == M-1:
            print("YES")
            sys.exit()

        for i in range(4):
            m_x = x + dx[i]
            n_y = y + dy[i]            

            if 0 <= m_x < M and 0 <= n_y < N:                
                if not visited[m_x][n_y] and maps[m_x][n_y] == 0:
                    visited[m_x][n_y] = True
                    queue.append((m_x,n_y))

for i in range(N):
    bfs(0,i,visited)

print("NO")
```
개선할 점은 visited 재사용하지 말고 bfs마다 생성하기 </br>
exit로 끝내기보단 retrun 사용하기 정도일것 같다 </br>

