## 문제
여는 괄호와 닫는 괄호만으로 이루어진 문자열이 주어진다. </br>
여기서 안정적인 문자열을 만들기 위한 최소 연산의 수를 구하려고 한다.  </br>
안정적인 문자열의 정의란 다음과 같다. </br>
- 빈 문자열은 안정적이다.
- S가 안정적이라면, {S}도 안정적인 문자열이다.
- S와 T가 안정적이라면, ST(두 문자열의 연결)도 안정적이다.

{}, {}{}, {{}{}}는 안정적인 문자열이지만, }{, {{}{, {}{는 안정적인 문자열이 아니다. </br>
문자열에 행할 수 있는 연산은 여는 괄호를 닫는 괄호로 바꾸거나, 닫는 괄호를 여는 괄호로 바꾸는 것 2가지이다. </br>

## 입력
입력은 여러 개의 데이터 세트로 이루어져 있다.  </br>
각 데이터 세트는 한 줄로 이루어져 있다. 줄에는 여는 괄호와 닫는 괄호만으로 이루어진 문자열이 주어진다. </br>
문자열의 길이가 2000을 넘는 경우는 없고, 항상 길이는 짝수이다. </br>
입력의 마지막 줄은 '-'가 한 개 이상 주어진다. </br>

## 출력
각 테스트 케이스에 대해서,  </br>
테스트 케이스 번호와 입력으로 주어진 문자열을 안정적으로 바꾸는데 필요한 최소 연산의 수를 출력한다.

## 풀이
안정적인지 확인하고 안정적이지 않으면 stack에 </br>
안정적이게 되면 ( '{' 다음 '}' 이 나오면 ) 그전에 stack에 넣었던 ('{') pop으로 빼주었다. </br>
이런식으로 안정적이 안나올때 까지 반복해줬다. </br>
남은 애들을 }}..{{ 형태이기 떄문에 남은 길이의 /2 하여 최소수를 구하였다. </br>
```python
def safe(S):
  stack = []
  
  temp = 'no'
  no_safe_check = 0

  first = S[0]
    
  for s in S:       

    if temp == '{' and s == '}':
      print('안정')
      pre = stack.pop()
      no_safe_check+=1
  
    else:
      stack.append(s)
  
    temp = s

  if no_safe_check == 0:
    print('finish')
    stack = []
    
  return stack


def calucate(S):
  result = []
  safe_result = S
  
  while True:  
    safe_result = safe(safe_result)
    print('safe',safe_result)
  
    if safe_result == []:
      print('ff')
      break
    result = safe_result
  
  print('result',result)
  
  re_len = len(result)
  print(re_len//2)


while True:
  test_case_result = []
  
  S = list(input())
  
  if '-' in S:
    break
  print(S)
  result = calucate(S)
  print('tc',result)

  test_case_result.append(result)
  
```

이때 안정적이 안나올때를 어떻게 체크하냐에 문제였다. </br>
처음엔 안정적 나오 조건문에 count 달아서 했는데 이러면 첫 시작이 } 이면 바로 끝나버린다. </br>
그래서 이런저런 조건을 붙이다가 아닌거 같아서 힌트를 받았다. </br>

힌트
- temp로 접근을 하면 안됐음, 이전 이랑 비교가 아닌 아직 짝을 찾지 못한 최근의 { 애로 해야한다.
- no_safe_check도 잘못됨, 이번 순회 없어도 다음에 나올 수 있음
- 스택을 여러번 돌리는게 아니고 한번의 순회로 끝나야한다


```python
def cal(S):

  stack = []
  for s in S:
    #print(s)

    if stack and stack[-1] == '{' and s == '}':
      stack.pop()
  
    else:
      stack.append(s)

  return stack

cnt = 0

while True:
  cnt += 1
  arr = list(input())
  #print(arr)

  if '-' in arr:
    break
  
  not_safety = cal(arr)
  print(not_safety)
  
  open_cnt = not_safety.count('{')
  close_cnt = not_safety.count('}')
  
  result = (open_cnt+1)//2 + (close_cnt+1)//2
  
  print(cnt,'. ',result,sep='')
```
훨씬 깔끔하게 정답을 구할수 있었다. </br>
일단 위에선 stack을 쓴이유가 없는 코드였다.</br>
그냥 이름만 stack인 배열에 temp를 사용해버린 거였고, 스택을 활용하기 위해서 조건따라 pop과 append를 해주었다.</br>

다음으로 필요했던 아이디어는 바꾸기 횟수를 구하는 것이었다.</br>
}{ 같은 경우는 2번, }}}{{{ 는 4번의 변경이 필요하다.</br>
안정적인 경우는 다 제외했기때문에 남은 형태는 }}}...{{{{이다.</br>

이때 크게 close부분'}' open부분'{' 으로 나누어보면, 각 부분이 짝수인경우는 /2로 짝지워진다.</br>
홀수인경우는 맞은편 부분과 짝지어진다.</br>
즉 짝수인경우는 }}형태로 둘중 하나만 변경, 홀수 인경우 }{ 형태로 둘다 변경해야한다.</br>
이걸 토대로 각각 open과 close의 수를 구하고 /2를 해주는데 홀수인경우 수를 더해줘야한다.</br>

이걸 식으로 나타내면 (n+1) //2 가 된다.</br>
} 1번이동 (반대편이랑)</br>
}} 1번이동 (둘이 해결)</br>
}}} 2번이동</br>
}}}} 2번이동</br>
이런식으로 식을 도출</br>
