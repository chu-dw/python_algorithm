## 문제
여는 괄호와 닫는 괄호만으로 이루어진 문자열이 주어진다. </br>
여기서 안정적인 문자열을 만들기 위한 최소 연산의 수를 구하려고 한다.  </br>
안정적인 문자열의 정의란 다음과 같다. </br>
- 빈 문자열은 안정적이다.
- S가 안정적이라면, {S}도 안정적인 문자열이다.
- S와 T가 안정적이라면, ST(두 문자열의 연결)도 안정적이다.

{}, {}{}, {{}{}}는 안정적인 문자열이지만, }{, {{}{, {}{는 안정적인 문자열이 아니다. </br>
문자열에 행할 수 있는 연산은 여는 괄호를 닫는 괄호로 바꾸거나, 닫는 괄호를 여는 괄호로 바꾸는 것 2가지이다. </br>

## 입력
입력은 여러 개의 데이터 세트로 이루어져 있다.  </br>
각 데이터 세트는 한 줄로 이루어져 있다. 줄에는 여는 괄호와 닫는 괄호만으로 이루어진 문자열이 주어진다. </br>
문자열의 길이가 2000을 넘는 경우는 없고, 항상 길이는 짝수이다. </br>
입력의 마지막 줄은 '-'가 한 개 이상 주어진다. </br>

## 출력
각 테스트 케이스에 대해서,  </br>
테스트 케이스 번호와 입력으로 주어진 문자열을 안정적으로 바꾸는데 필요한 최소 연산의 수를 출력한다.

## 풀이
안정적인지 확인하고 안정적이지 않으면 stack에 </br>
안정적이게 되면 ( '{' 다음 '}' 이 나오면 ) 그전에 stack에 넣었던 ('{') pop으로 빼주었다. </br>
이런식으로 안정적이 안나올때 까지 반복해줬다. </br>
남은 애들을 }}..{{ 형태이기 떄문에 남은 길이의 /2 하여 최소수를 구하였다. </br>
```python
def safe(S):
  stack = []
  
  temp = 'no'
  no_safe_check = 0

  first = S[0]
    
  for s in S:       

    if temp == '{' and s == '}':
      print('안정')
      pre = stack.pop()
      no_safe_check+=1
  
    else:
      stack.append(s)
  
    temp = s

  if no_safe_check == 0:
    print('finish')
    stack = []
    
  return stack


def calucate(S):
  result = []
  safe_result = S
  
  while True:  
    safe_result = safe(safe_result)
    print('safe',safe_result)
  
    if safe_result == []:
      print('ff')
      break
    result = safe_result
  
  print('result',result)
  
  re_len = len(result)
  print(re_len//2)


while True:
  test_case_result = []
  
  S = list(input())
  
  if '-' in S:
    break
  print(S)
  result = calucate(S)
  print('tc',result)

  test_case_result.append(result)
  
```

이때 안정적이 안나올때를 어떻게 체크하냐에 문제였다. </br>
처음엔 안정적 나오 조건문에 count 달아서 했는데 이러면 첫 시작이 } 이면 바로 끝나버린다. </br>
그래서 이런저런 조건을 붙이다가 아닌거 같아서 힌트를 받았다. </br>

힌트
- temp로 접근을 하면 안됐음, 이전 이랑 비교가 아닌 아직 짝을 찾지 못한 최근의 { 애로 해야한다.
- no_safe_check도 잘못됨, 이번 순회 없어도 다음에 나올 수 있음
- 스택을 여러번 돌리는게 아니고 한번의 순회로 끝나야한다
