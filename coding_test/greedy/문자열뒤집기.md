# 문자열 뒤집기

## 문제
0과1로만 이루어진 문자열 s, </br>
문자열 s에 있는 모든 숫자를 전부 같게 만들기 </br>
s에 연속된 하나 이상의 숫자를 잡고 모두 뒤집을수 있음 </br>
예를 들어 0001100이면
- 전체뒤집기 : 1110011
- 4번째 부터 5번째 연속된 00 뒤집기
두번으로 모두 1로 만듦, 하지만
- 바로 4,5번째 연속된 1 뒤집기
한번만으로 가능함 </br>

이처럼 최소로 뒤집어 같은문자로 만드는 횟수를 구하라. </br>

## 입력
첫쨰 줄에 0과 1로만 이루어진 문자열 S주어짐, S길이는 100만 보다 작음

## 출력
첫째중에 모두 같은 문자로 만드는 뒤집기의 최소 횟수를 출력

## 풀이
다 0이 되거나 1이 되는 두가지 경우만 있기때문에 </br>
각각의 경우중 최소 값을 도출하면 될것이라 생각했다. </br>
연속은 수가 바뀔때만 cnt 를 +시키는 방법으로 접근했다. </br>

```python
S = list(map(int,input()))

change_zero = 0
change_one = 1

cnt_one = 0
cnt_zero = 0

chnage_one_temp = 2
chagne_zero_temp = 2

for s in S:
  print('s',s)
  
  if s == 1 and chagne_zero_temp != 1:
    print('c1')
    cnt_zero += 1

  elif s == 0 and chnage_one_temp != 0:
    print('c0')
    cnt_one += 1

  chnage_one_temp = s
  chagne_zero_temp = s

print(cnt_one)
print(cnt_zero)

result = min(cnt_one, cnt_zero)
print(result)

```

개선 </br>
- temp는 이전 수만 추척하니까 굳이 두개 필요없음 </br>
- 거기에 인덱스로 접근 하는 방법이 더 정석적(논리가 잘 보임) </br>
- temp라는 별로 변수 있으면 상태 분산 </br>

```python
S = list(map(int,input()))

cnt_one = 0
cnt_zero = 0

if S[0] == 1:
  cnt_zero += 1
else:
  cnt_one += 1

for i in range(1,len(S)):
  if S[i] != S[i-1]:   

    if S[i] == 0:
      cnt_one += 1 
    else:
      cnt_zero += 1
    
print(cnt_one)
print(cnt_zero)

result = min(cnt_one, cnt_zero)
print(result)
```

