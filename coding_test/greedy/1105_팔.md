# 팔

## 문제
L과 R이 주어진다. 이때, L보다 크거나 같고, R보다 작거나 같은 자연수 중에 </br>
8이 가장 적게 들어있는 수에 들어있는 8의 개수를 구하는 프로그램을 작성하시오</br>

## 입력
첫째 줄에 L과 R이 주어진다. L은 2,000,000,000보다 작거나 같은 자연수이고, </br>
R은 L보다 크거나 같고, 2,000,000,000보다 작거나 같은 자연수이다.</br>

## 출력
첫째 줄에 L보다 크거나 같고, R보다 작거나 같은 자연수 중에</br>
8이 가장 적게 들어있는 수에 들어있는 8의 개수를 구하는 프로그램을 작성하시오.</br>

## 풀이
처음에는 일단 하나씩 접근해서 구해봤다. 당연히 시간초과이다. </br>
풀기전에 예상을 좀 더 체계적으로 할 필요도 있을것 같다.</br>
일반적으로 파이썬에서 1억이상 루프는 무조건 시간초과이다. </br>
간단하게 아래 표정도는 숙지하고 있어야할거 같다.</br>

| 시간복잡도          | 가능한 N 범위   | 대표 알고리즘 / 예시                                                     |
| -------------- | ---------- | ---------------------------------------------------------------- |
| **O(1)**       | 무제한        | 딕셔너리 접근, 수식 계산<br>ex) `a + b`, `dict[key]`                       |
| **O(log N)**   | ≥ 10⁸      | 이진 탐색<br>ex) 정렬된 배열에서 탐색<br>매개변수 탐색                              |
| **O(√N)**      | \~10⁸      | 약수 찾기, 에라토스테네스의 체<br>ex) 소수 판별, 소인수 분해                           |
| **O(N)**       | \~10⁷      | 선형 탐색, 배열 순회, BFS/DFS(얕은 그래프)<br>ex) 누적합, 카운팅, 단일 루프             |
| **O(N log N)** | \~5 \* 10⁶ | 병합정렬, 퀵정렬, LIS(DP + 이분탐색)<br>ex) 정렬, 트리 탐색, 우선순위 큐               |
| **O(N²)**      | \~3000     | 이중 for문, 브루트포스, 플로이드(3중 루프 가능할 때도 있음)<br>ex) 모든 쌍 비교, NxN 격자 BFS |
| **O(N³)**      | \~500      | 3중 루프, DP + 모든 상태 탐색<br>ex) 플로이드-워셜, 문자열 편집거리                    |
| **O(2ⁿ)**      | ≤ 20\~25   | 부분집합 탐색, 백트래킹<br>ex) 조합, DFS 상태탐색, 비트마스킹                         |
| **O(n!)**      | ≤ 8\~10    | 모든 순열/경우의 수 다 봐야 하는 문제<br>ex) 순열 탐색, 여행자 순회 문제 (TSP)             |
</br>
다시 문제로 돌아와서 시간초가가 안나게 하려면</br>
자리수로 생각을 해야한다.</br>
일단 서로 자리수가 다를경우 무조건 8 이 안들어간 수가 생기게된다.</br>
자리수가 넘어가는 첫수는 항상 100, 1000, 10000 일테니까 말이다.</br>
자리수가 같을경우만 비교하면 되는데</br>
이때도 앞자리수 부터 8이 같이 겹치는게 몇개인지 보면된다.</br>
803 902 면 앞자리부터 안겹친다. 그러면 900 처럼 8이 없는수가 가능하다.</br>
803 888 이면 앞자리만 겹친다. 그러면 80X가 8이 가장 적게들어가 1개가 된다.</br>

```pythond
L, R = map(int,input().split())

L = str(L)
R = str(R)
L_len = len(L)
R_len = len(R)

count = 0

if L_len == R_len:

  for i in range(L_len):
    print('LR',L[i], R[i])
    if L[i] == '8' and R[i] == '8':
      count += 1
    else:
      break

  print(count)

else:
  print(0)
```
근데 위 코드도 틀렸다고한다.</br>
181 189 가 반례였다</br>
1을 count해야하지만 1,1에서 break를 걸어버려 0이 나온다.</br>
앞자리가 같고 뒷자리가 8인경우도 8이 겹치기 때문에</br>
if 문을 일단 두수 같은지 확인한 후 그 수가 8인경우만 count 하도록 바꾸었다.</br>

```python
L, R = map(int,input().split())

L = str(L)
R = str(R)
L_len = len(L)
R_len = len(R)

count = 0

if L_len == R_len:

  for i in range(L_len):
    #print('LR',L[i], R[i])
    if L[i] == R[i]:
      if L[i] == '8':
        count += 1
    else:
      break

  print(count)

else:
  print(0)
```
