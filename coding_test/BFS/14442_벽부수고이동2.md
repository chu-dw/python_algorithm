# 벽 부수고 이동하기2

## 문제
N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, </br>
1은 이동할 수 없는 벽이 있는 곳을 나타낸다.  </br>
당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. </br>
최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다. </br>
만약에 이동하는 도중에 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면,  </br>
벽을 K개 까지 부수고 이동하여도 된다. </br>
한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다. </br>
맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오. </br>

## 입력
첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000), K(1 ≤ K ≤ 10)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. </br>
(1, 1)과 (N, M)은 항상 0이라고 가정하자. </br>

## 출력
첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다. </br>

## 풀이1
bfs 큐에 넣는값을 늘려 길이와 부순 벽을 추적해야한다 생각했다. </br>
그럴러면 visited도 3차원으로 부순 벽 에따라 따로 기록 해줘야한다. </br>

```python
import sys
from collections import deque

N, M, K = map(int, input().split())
#N 세로 row, M 가로 col

maps = []
dr = [-1,1,0,0]
dc = [0,0,-1,1]

visited = [[[False]*(K+1) for _ in range(M)] for _ in range(N)] 

for _ in range(N):
  maps.append(list(map(int, sys.stdin.readline().strip())))
#print(maps)

def bfs(x, y, visited, count, val):
  queue = deque([(x,y,count,val)])
  visited[x][y][0] = True

  while queue:
    row, col, count, val = queue.popleft()
    #print(queue)
    
    for i in range(4):
      row2 = row + dr[i]
      col2 = col + dc[i]      
      
      if 0 <= row2 < N and 0 <= col2 < M and not visited[row2][col2][count]:
        #print('roco',row2,col2,'maps', maps[row2][col2], 'count',count)
        if maps[row2][col2] == 0:
          visited[row2][col2][count] = True
          queue.append((row2,col2,count,val+1))
          #print('여기가 안들어가?',queue)
        
        elif maps[row2][col2] == 1 and count < K:
          #print('벽부셔')          
          visited[row2][col2][count+1] = True
          queue.append((row2,col2,count+1,val+1))
          #print('왜안들어가',queue)          
        
  return val

val = bfs(0,0,visited,0,K)

print(val)
          

```
계속 visited쪽이 꼬여서 오답이나왔다. </br>
3차원이 정리가 잘 안돼서 약간 때려 넣는 느낌으로 진행해서 그런것 같다. </br>

3차원이라 생각안하고 2차원이 k개라고 생각하면 된다. </br>
부술수 있는 벽의 수가 k개니까  </br>
총 경우의 수가 k개 나온다. 1개부수고 도착, 2개 부수고 도착.., </br>
이걸 각각의 2차원 배열에 저장한다고 생각하면 된다. </br>
일단 쉽게 k가 2라고해보자 </br>
그럼 1층은 하나도 안부구소 갈때의 visited를 2층은 한번 부수고 가는 visited를 저장한다. </br>
부수고 올라 갔을경우 이전 지나온길도 다시 지나갈 수 있다. </br>


## 풀이2
```python
import sys
from collections import deque

N, M, K = map(int, sys.stdin.readline().split())
#N 세로 r ,M 가로 c

maps = []
visited =[[[False]*(K+1) for _ in range(M)]for _ in range(N)]
#print(visited)
dr = [0,0,-1,1]
dc = [-1,1,0,0]

for _ in range(N):
  maps.append(list(map(int,sys.stdin.readline().strip())))

#print(maps)


def bfs(r,c,broke, dist):
  queue = deque([(r,c,broke,dist)])
  visited[r][c][broke] = True
  
  while queue:
    r,c,broke,dist = queue.popleft()

    if r == N-1 and c == M-1:
      return dist

    for i in range(4):
      nr = r + dr[i]
      nc = c + dc[i]
     
      if 0 <= nr < N and 0 <= nc < M:

        #print(nr,nc,broke,dist)       
        
        if maps[nr][nc] == 0 and not visited[nr][nc][broke]:
          #print('if', nr, nc, broke)
          visited[nr][nc][broke] = True          
          queue.append((nr,nc,broke,dist+1))
          
        elif maps[nr][nc] == 1 and broke < K and not visited[nr][nc][broke+1]:
          #print('elif', nr, nc, broke)
          visited[nr][nc][broke+1] = True          
          queue.append((nr,nc,broke+1,dist+1))

  return -1
    
dist = bfs(0,0,0,1)
print(dist)
```
visited 잘 적용해서 다시 풀었으나 이번에는 시간초과가 났다.

# 풀이3
```python
import sys
from collections import deque

input = sys.stdin.readline

N, M, K = map(int, input().split())
#N 세로 r ,M 가로 c

maps = []
visited =[[[-1]*(K+1) for _ in range(M)]for _ in range(N)]
#print(visited)
dr = [0,0,-1,1]
dc = [-1,1,0,0]

for _ in range(N):
  maps.append(list(map(int,input().strip())))

#print(maps)

def bfs(r,c,broke):  
  queue = deque([(r,c,broke)])
  visited[r][c][broke] = 1
  
  while queue:
    r,c,broke= queue.popleft()
    dist = visited[r][c][broke]

    if r == N-1 and c == M-1:
      return visited[r][c][broke]
      

    for i in range(4):
      nr = r + dr[i]
      nc = c + dc[i]
     
      if 0 <= nr < N and 0 <= nc < M:

        #print(nr,nc,broke,dist)       
        
        if maps[nr][nc] == 0 and visited[nr][nc][broke] == -1:
          #print('if', nr, nc, broke)
          visited[nr][nc][broke] = dist+1       
          queue.append((nr,nc,broke))
          
        if maps[nr][nc] == 1 and broke < K and visited[nr][nc][broke+1] == -1:
          #print('elif', nr, nc, broke)
          visited[nr][nc][broke+1] = dist+1      
          queue.append((nr,nc,broke+1))

  return -1

dist = bfs(0,0,0)
print(dist)
```
dist를 queue에서 빼 따로 저장하는 방식으로 바꾸었다. </br>
bfs에서 큐 연산이 많을 떄 append, popleft가 최대 병목 지점이다.</br>
visited 에서 true false를 저장 하는대신 그 위치 까지의 거리를 저장한다.</br>
이때 따로 큐에서 꺼낼 수없으므로 반복문 돌때마다 현재 dist값을 visited에서 꺼내주어야한다.</br>

하지만 이렇게해도 시간초과가 났다 pypy로 컴파일하면 돌아가긴한다.</br>
조금 더 시간 줄일방법이 없을까?</br>

일단 gpt의 답은 아래와 같다...</br>

방문 배열 압축 </br>
visited[r][c]를 정수 비트마스크로 두고, broke 상태를 비트로 관리 </br>
예: visited[r][c] & (1<<broke) → 방문 체크 </br>
이렇게 하면 메모리 접근량을 줄일 수 있어요.</br>
하지만 Python 비트연산도 그렇게까지 빠르지는 않아서 큰 차이 없을 수도 있습니다. </br>

deque 대신 직접 배열 인덱스 큐 구현 </br>
collections.deque도 빠르지만, 1천만 단위에서는 오버헤드가 커집니다. </br>
직접 리스트 하나 두고, head와 tail 인덱스만 움직이는 원형 큐를 쓰면 조금 더 빨라집니다. </br>

PyPy 전용 최적화 포기 + C++ 권장 </br>
이 문제는 BOJ에서도 Python3는 **"시간초과 판정 정상"**이라고 나오는 경우가 많습니다. </br>

이 뭔가 찝찝한 마무리.. </br>
