# 치즈

## 문제
N×M의 모눈종이 위에 아주 얇은 치즈가 <그림 1>과 같이 표시되어 있다. 단, N 은 세로 격자의 수이고, M 은 가로 격자의 수이다.  </br>
이 치즈는 냉동 보관을 해야만 하는데 실내온도에 내어놓으면 공기와 접촉하여 천천히 녹는다.  </br>
그런데 이러한 모눈종이 모양의 치즈에서 각 치즈 격자(작 은 정사각형 모양)의 4변 중에서  </br>
적어도 2변 이상이 실내온도의 공기와 접촉한 것은 정확히 한시간만에 녹아 없어져 버린다. </br>
따라서 아래 <그림 1> 모양과 같은 치즈(회색으로 표시된 부분)라면 C로 표시된 모든 치즈 격자는 한 시간 후에 사라진다. </br>

<그림 2>와 같이 치즈 내부에 있는 공간은 치즈 외부 공기와 접촉하지 않는 것으로 가정한다.  </br>
그러므 로 이 공간에 접촉한 치즈 격자는 녹지 않고 C로 표시된 치즈 격자만 사라진다.  </br>
그러나 한 시간 후, 이 공간으로 외부공기가 유입되면 <그림 3>에서와 같이 C로 표시된 치즈 격자들이 사라지게 된다. </br>

모눈종이의 맨 가장자리에는 치즈가 놓이지 않는 것으로 가정한다. </br>
입력으로 주어진 치즈가 모두 녹아 없어지는데 걸리는 정확한 시간을 구하는 프로그램을 작성하시오. </br>

## 입력
첫째 줄에는 모눈종이의 크기를 나타내는 두 개의 정수 N, M (5 ≤ N, M ≤ 100)이 주어진다.  </br>
그 다음 N개의 줄에는 모눈종이 위의 격자에 치즈가 있는 부분은 1로 표시되고, 치즈가 없는 부분은 0으로 표시된다. </br>
또한, 각 0과 1은 하나의 공백으로 분리되어 있다. </br>

## 출력
출력으로는 주어진 치즈가 모두 녹아 없어지는데 걸리는 정확한 시간을 정수로 첫 줄에 출력한다. </br>

## 풀이1
일단은 최대 탐색구간이 100*100이기 때문에 다 돌아도 되지않을까해서 풀어보았다. </br>
단순하게 전체 돌면서 1이면 주변에 공기 몇개인지 cout함수로 세고 2개 이상이면  </br>
copy한 map에 적용하고 한바퀴 돌면 return 한 후 진짜 map에 적용해주었다. </br>
```python
import sys
import copy

input = sys.stdin.readline
N,M = map(int, input().split())
# N 세로 row,  M 가로 col

maps = []
dr = [0,0,-1,1]
dc = [-1,1,0,0]

for _ in range(N):
    maps.append(list(map(int,input().split())))

#print(maps)
def count_near_air(row,col,maps):
    count = 0
    for i in range(4):
        r = row + dr[i]
        c = col + dc[i]
        if maps[r][c] == 0:
            count += 1
    return count

def melt_cheese(maps):  

    copy_map = copy.deepcopy(maps)
    cheese_count = 0
    
    for row in range(N):
        for col in range(M):
            if maps[row][col] == 1:
                cheese_count += 1 
                #print(row,col)
                air_count = count_near_air(row,col,maps)
                #print("aircount",air_count)
                if air_count >= 2:
                    copy_map[row][col] = 0
                #print("변경map\n",copy_map, 'maps\n',maps)
                
    if cheese_count == 0:
        return 0
    return copy_map

time_count = 0
while True:    
    copy_map = melt_cheese(maps)
    maps = copy_map
    #print('maps변경 적용\n',maps)
    if maps == 0:
        print(time_count)
        break
    time_count += 1
```

## 풀이2
문제에 놓친게 있었다, </br>
너무 대충읽었네.. 그래도 골드3문제인데 </br>
치즈에 갇혀있는 공기는 외부 공기로 적용되지않는다. </br>
bfs를 이용해 외부 공기를 따로 바꿔준다음 적용해서 다시 풀어보았다. </br>

```python
import sys
import copy
from collections import deque

input = sys.stdin.readline

N,M = map(int, input().split())
# N 세로 row,  M 가로 col

maps = []
dr = [0,0,-1,1]
dc = [-1,1,0,0]

for _ in range(N):
    maps.append(list(map(int,input().split())))

#print(maps)

def bfs_air_check(row,col,maps):
    
    air_visited = [[False]*M for _ in range(N)]    
    queue = deque([(row,col)])
    
    while queue:
        row,col = queue.popleft()
        air_visited[row][col] = True
        maps[row][col] = 2
        
        for i in range(4):
            r = row + dr[i]
            c = col + dc[i]
            if 0 <= r < N and 0 <= c < M:
                if not air_visited[r][c] and maps[r][c] == 0:
                    air_visited[r][c] = True
                    maps[r][c] = 2
                    queue.append((r,c))

def count_near_air(row,col,maps):
    count = 0
    for i in range(4):
        r = row + dr[i]
        c = col + dc[i]
        if maps[r][c] == 2:
            count += 1
    return count
    

def melt_cheese(maps):  

    copy_map = copy.deepcopy(maps)
    cheese_count = 0
    
    for row in range(N):
        for col in range(M):
            if maps[row][col] == 1:
                cheese_count += 1 
                #print(row,col)
                air_count = count_near_air(row,col,maps)
                #print("aircount",air_count)
                if air_count >= 2:
                    copy_map[row][col] = 2
                #print("변경map\n",copy_map, 'maps\n',maps)
    #print('cheesecount',cheese_count)
    if cheese_count == 0:
        return 0
    return copy_map


bfs_air_check(0,0,maps)
#print('aircheck\n',maps)


time_count = 0
while True:    
    copy_map = melt_cheese(maps)
    maps = copy_map
    #print('maps변경 적용\n',maps)
    if maps == 0:
        print(time_count)
        break
    time_count += 1
```

## 풀이3
답은 잘 나온다 하지만 불안했던 시간 초과가 났다. </br>
인줄 알았는데 치즈가 녹을때마다 외부 공기가 바뀌기때문에 </br>
bfs를 매번 돌려줘야한다. </br>
시간 초과가 나는이유는 deepcopy때문이라고 한다. </br>
그래서 deepcopy를 없애고  </br>
리스트로 녹는 좌표를 미리 저장하고 한번에 업데이트 해주는 방식으로 수정했다. </br>
```python
import sys
from collections import deque

input = sys.stdin.readline

N,M = map(int, input().split())
# N 세로 row,  M 가로 col

maps = []
dr = [0,0,-1,1]
dc = [-1,1,0,0]

for _ in range(N):
    maps.append(list(map(int,input().split())))
#print(maps)

def bfs_air_check(row,col,maps):    
    air_visited = [[False]*M for _ in range(N)]    
    queue = deque([(row,col)])
    
    while queue:
        row,col = queue.popleft()
        air_visited[row][col] = True
        maps[row][col] = 2
        
        for i in range(4):
            r = row + dr[i]
            c = col + dc[i]
            if 0 <= r < N and 0 <= c < M:
                if not air_visited[r][c] and maps[r][c] == 0:
                    air_visited[r][c] = True
                    maps[r][c] = 2
                    queue.append((r,c))

def count_near_air(row,col,maps):
    count = 0
    for i in range(4):
        r = row + dr[i]
        c = col + dc[i]
        if maps[r][c] == 2:
            count += 1
    return count
    

def melt_cheese(maps):  
    melt_rc = []
    cheese_count = 0
    
    for row in range(N):
        for col in range(M):
            if maps[row][col] == 1:
                cheese_count += 1 
                #print(row,col)
                air_count = count_near_air(row,col,maps)
                #print("aircount",air_count)
                if air_count >= 2:
                    melt_rc.append((row,col))                
    #melt적용
    #print(melt_rc)
    for r,c in melt_rc:
        #print('rc',r,c)
        maps[r][c] = 2
        
    #print('cheesecount',cheese_count)
    if cheese_count == 0:
        return True
    return False
    
#print('aircheck\n',maps)
time_count = 0
while True:    
    bfs_air_check(0,0,maps)
    re_copy_map = melt_cheese(maps)
    
    #print('maps변경 적용\n',maps)
    if re_copy_map:
        print(time_count)
        break
    time_count += 1
```

# 풀이4
하지만 여전히 시간초과가 난다 </br>

BFS 공기 영역 초기화 최적화 </br>
현재는 BFS로 외부 공기를 계속 0→2로 바꿔가며 마킹 중. </br>
하지만 매번 전체 BFS 돌릴 필요는 없음. </br>
→ 사실 visited 배열을 두고 BFS 할 때마다 초기화해도 됨. </br>
또는 maps 배열에 2를 유지하지 않고, 그때그때 BFS 탐색 결과만 활용하는 방식도 가능. </br>

치즈 위치 관리 </br>
지금은 melt_cheese에서 전체 배열을 돌면서 치즈를 찾음. </br>
→ 치즈 좌표를 set/list에 따로 저장해두고, 매 루프마다 그 집합만 확인하면 O(치즈 개수)만큼만 확인 가능. </br>

count_near_air 개선 </br>
네 함수는 if maps[r][c] == 2: 만 체크해서 외부공기(2)만 인식함. </br>
하지만 매번 BFS로 외부공기를 2로 마킹하는 게 부담. </br>
→ 대신 BFS마다 visited[][] 사용하면 매번 **공기 탐색 후 "외부공기 집합"**만 만들고 그거로 녹일 치즈 찾을 수 있음. </br>

라고 gpt에게 도움을 받았다 이걸 바탕으로 다시 </br>

일단 공기를 bfs돌릴때 2로 계속 바꿔주지않고  </br>
bfs에 쓰는 visited를 반환해 공기체크를 했다. </br>
녹는 치즈 구할때는 그래도 전체 순화을 사용했다. </br>
그래도 시간초과는 나지 않았다. </br>
뭔가 오래 푼건데 풀고나니 쉽게 풀려버린 느낌이다.. </br>
```python
import sys
from collections import deque
input = sys.stdin.readline

N, M = map(int, input().split())
maps = [list(map(int, input().split())) for _ in range(N)]

#  N이 세로 r ,M 이 가로 c 8 

dr = [0, 0, -1, 1]
dc = [-1, 1, 0, 0]

#print(maps)

def bfs_air(x,y,maps):

    visited = [[False]*M  for _ in range(N)]

    queue = deque([(x,y)])
    visited[x][y] =True

    while queue:
        x1, y1 = queue.popleft()        

        for i in range(4):            
            row = x1 + dr[i]
            col = y1 + dc[i]
            
            if 0 <= row < N and 0 <= col < M and not visited[row][col]:
                #print('test',row, col)
                if maps[row][col] == 0:
                    visited[row][col] = True
                    queue.append((row,col))

    return visited

    

def melt_cheese(visited): 

    cheese_count = 0
    melt_list = []
    
    for n in range(N):
        for m in range(M):
            if maps[n][m]==1:
                near_cheese = 0   
                cheese_count += 1
                
                for i in range(4):                    
                    row = n + dr[i] 
                    col = m + dc[i]
                    if 0 <= row < N and 0 <= col < M:
                        if visited[row][col]:
                            near_cheese += 1
                    if near_cheese >= 2:
                        melt_list.append((n,m))

    if cheese_count == 0:
        return "finsh"
        
    for row, col in melt_list:
        maps[row][col] = 0
    
    return 0

count = 0
while True:
    visited = []
    visited = bfs_air(0,0,maps)
    result = melt_cheese(visited)
    
    if result == 'finsh':
        print(count)
        break
    count += 1

    #print(visited)
    #print(maps)
```

