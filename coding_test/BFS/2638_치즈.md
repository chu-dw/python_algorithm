# 치즈

## 문제
N×M의 모눈종이 위에 아주 얇은 치즈가 <그림 1>과 같이 표시되어 있다. 단, N 은 세로 격자의 수이고, M 은 가로 격자의 수이다. 
이 치즈는 냉동 보관을 해야만 하는데 실내온도에 내어놓으면 공기와 접촉하여 천천히 녹는다. 
그런데 이러한 모눈종이 모양의 치즈에서 각 치즈 격자(작 은 정사각형 모양)의 4변 중에서 
적어도 2변 이상이 실내온도의 공기와 접촉한 것은 정확히 한시간만에 녹아 없어져 버린다.
따라서 아래 <그림 1> 모양과 같은 치즈(회색으로 표시된 부분)라면 C로 표시된 모든 치즈 격자는 한 시간 후에 사라진다.

<그림 2>와 같이 치즈 내부에 있는 공간은 치즈 외부 공기와 접촉하지 않는 것으로 가정한다. 
그러므 로 이 공간에 접촉한 치즈 격자는 녹지 않고 C로 표시된 치즈 격자만 사라진다. 
그러나 한 시간 후, 이 공간으로 외부공기가 유입되면 <그림 3>에서와 같이 C로 표시된 치즈 격자들이 사라지게 된다.

모눈종이의 맨 가장자리에는 치즈가 놓이지 않는 것으로 가정한다.
입력으로 주어진 치즈가 모두 녹아 없어지는데 걸리는 정확한 시간을 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에는 모눈종이의 크기를 나타내는 두 개의 정수 N, M (5 ≤ N, M ≤ 100)이 주어진다. 
그 다음 N개의 줄에는 모눈종이 위의 격자에 치즈가 있는 부분은 1로 표시되고, 치즈가 없는 부분은 0으로 표시된다.
또한, 각 0과 1은 하나의 공백으로 분리되어 있다.

## 출력
출력으로는 주어진 치즈가 모두 녹아 없어지는데 걸리는 정확한 시간을 정수로 첫 줄에 출력한다.

## 풀이1
일단은 최대 탐색구간이 100*100이기 때문에 다 돌아도 되지않을까해서 풀어보았다.
단순하게 전체 돌면서 1이면 주변에 공기 몇개인지 cout함수로 세고 2개 이상이면 
copy한 map에 적용하고 한바퀴 돌면 return 한 후 진짜 map에 적용해주었다.
```python
import sys
import copy

input = sys.stdin.readline
N,M = map(int, input().split())
# N 세로 row,  M 가로 col

maps = []
dr = [0,0,-1,1]
dc = [-1,1,0,0]

for _ in range(N):
    maps.append(list(map(int,input().split())))

#print(maps)
def count_near_air(row,col,maps):
    count = 0
    for i in range(4):
        r = row + dr[i]
        c = col + dc[i]
        if maps[r][c] == 0:
            count += 1
    return count

def melt_cheese(maps):  

    copy_map = copy.deepcopy(maps)
    cheese_count = 0
    
    for row in range(N):
        for col in range(M):
            if maps[row][col] == 1:
                cheese_count += 1 
                #print(row,col)
                air_count = count_near_air(row,col,maps)
                #print("aircount",air_count)
                if air_count >= 2:
                    copy_map[row][col] = 0
                #print("변경map\n",copy_map, 'maps\n',maps)
                
    if cheese_count == 0:
        return 0
    return copy_map

time_count = 0
while True:    
    copy_map = melt_cheese(maps)
    maps = copy_map
    #print('maps변경 적용\n',maps)
    if maps == 0:
        print(time_count)
        break
    time_count += 1
```

## 풀이2
문제에 놓친게 있었다,
너무 대충읽었네.. 그래도 골드3문제인데
치즈에 갇혀있는 공기는 외부 공기로 적용되지않는다.
bfs를 이용해 외부 공기를 따로 바꿔준다음 적용해서 다시 풀어보았다.

```python
import sys
import copy
from collections import deque

input = sys.stdin.readline

N,M = map(int, input().split())
# N 세로 row,  M 가로 col

maps = []
dr = [0,0,-1,1]
dc = [-1,1,0,0]

for _ in range(N):
    maps.append(list(map(int,input().split())))

#print(maps)

def bfs_air_check(row,col,maps):
    
    air_visited = [[False]*M for _ in range(N)]    
    queue = deque([(row,col)])
    
    while queue:
        row,col = queue.popleft()
        air_visited[row][col] = True
        maps[row][col] = 2
        
        for i in range(4):
            r = row + dr[i]
            c = col + dc[i]
            if 0 <= r < N and 0 <= c < M:
                if not air_visited[r][c] and maps[r][c] == 0:
                    air_visited[r][c] = True
                    maps[r][c] = 2
                    queue.append((r,c))

def count_near_air(row,col,maps):
    count = 0
    for i in range(4):
        r = row + dr[i]
        c = col + dc[i]
        if maps[r][c] == 2:
            count += 1
    return count
    

def melt_cheese(maps):  

    copy_map = copy.deepcopy(maps)
    cheese_count = 0
    
    for row in range(N):
        for col in range(M):
            if maps[row][col] == 1:
                cheese_count += 1 
                #print(row,col)
                air_count = count_near_air(row,col,maps)
                #print("aircount",air_count)
                if air_count >= 2:
                    copy_map[row][col] = 2
                #print("변경map\n",copy_map, 'maps\n',maps)
    #print('cheesecount',cheese_count)
    if cheese_count == 0:
        return 0
    return copy_map


bfs_air_check(0,0,maps)
#print('aircheck\n',maps)


time_count = 0
while True:    
    copy_map = melt_cheese(maps)
    maps = copy_map
    #print('maps변경 적용\n',maps)
    if maps == 0:
        print(time_count)
        break
    time_count += 1
```

## 풀이3
답은 잘 나온다 하지만 불안했던 시간 초과가 났다.
인줄 알았는데 치즈가 녹을때마다 외부 공기가 바뀌기때문에
bfs를 매번 돌려줘야한다.
시간 초과가 나는이유는 deepcopy때문이라고 한다.
그래서 deepcopy를 없애고 
리스트로 녹는 좌표를 미리 저장하고 한번에 업데이트 해주는 방식으로 수정했다.
```python
import sys
from collections import deque

input = sys.stdin.readline

N,M = map(int, input().split())
# N 세로 row,  M 가로 col

maps = []
dr = [0,0,-1,1]
dc = [-1,1,0,0]

for _ in range(N):
    maps.append(list(map(int,input().split())))
#print(maps)

def bfs_air_check(row,col,maps):    
    air_visited = [[False]*M for _ in range(N)]    
    queue = deque([(row,col)])
    
    while queue:
        row,col = queue.popleft()
        air_visited[row][col] = True
        maps[row][col] = 2
        
        for i in range(4):
            r = row + dr[i]
            c = col + dc[i]
            if 0 <= r < N and 0 <= c < M:
                if not air_visited[r][c] and maps[r][c] == 0:
                    air_visited[r][c] = True
                    maps[r][c] = 2
                    queue.append((r,c))

def count_near_air(row,col,maps):
    count = 0
    for i in range(4):
        r = row + dr[i]
        c = col + dc[i]
        if maps[r][c] == 2:
            count += 1
    return count
    

def melt_cheese(maps):  
    melt_rc = []
    cheese_count = 0
    
    for row in range(N):
        for col in range(M):
            if maps[row][col] == 1:
                cheese_count += 1 
                #print(row,col)
                air_count = count_near_air(row,col,maps)
                #print("aircount",air_count)
                if air_count >= 2:
                    melt_rc.append((row,col))                
    #melt적용
    #print(melt_rc)
    for r,c in melt_rc:
        #print('rc',r,c)
        maps[r][c] = 2
        
    #print('cheesecount',cheese_count)
    if cheese_count == 0:
        return True
    return False
    
#print('aircheck\n',maps)
time_count = 0
while True:    
    bfs_air_check(0,0,maps)
    re_copy_map = melt_cheese(maps)
    
    #print('maps변경 적용\n',maps)
    if re_copy_map:
        print(time_count)
        break
    time_count += 1
```

# 풀이4
하지만 여전히 시간초과가 난다

BFS 공기 영역 초기화 최적화
현재는 BFS로 외부 공기를 계속 0→2로 바꿔가며 마킹 중.
하지만 매번 전체 BFS 돌릴 필요는 없음.
→ 사실 visited 배열을 두고 BFS 할 때마다 초기화해도 됨.
또는 maps 배열에 2를 유지하지 않고, 그때그때 BFS 탐색 결과만 활용하는 방식도 가능.

치즈 위치 관리
지금은 melt_cheese에서 전체 배열을 돌면서 치즈를 찾음.
→ 치즈 좌표를 set/list에 따로 저장해두고, 매 루프마다 그 집합만 확인하면 O(치즈 개수)만큼만 확인 가능.

count_near_air 개선
네 함수는 if maps[r][c] == 2: 만 체크해서 외부공기(2)만 인식함.
하지만 매번 BFS로 외부공기를 2로 마킹하는 게 부담.
→ 대신 BFS마다 visited[][] 사용하면 매번 **공기 탐색 후 "외부공기 집합"**만 만들고 그거로 녹일 치즈 찾을 수 있음.

라고 gpt에게 도움을 받았다 이걸 바탕으로 다시

