# 영역 구하기

## 문제
눈금의 간격이 1인 M×N(M,N≤100)크기의 모눈종이가 있다. </br>
이 모눈종이 위에 눈금에 맞추어 K개의 직사각형을 그릴 때, 이들 K개의 직사각형의 내부를 제외한 나머지 부분이 몇 개의 분리된 영역으로 나누어진다. </br>
예를 들어 M=5, N=7 인 모눈종이 위에 <그림 1>과 같이 직사각형 3개를 그렸다면, </br>
그 나머지 영역은 <그림 2>와 같이 3개의 분리된 영역으로 나누어지게 된다. </br>
<그림 2>와 같이 분리된 세 영역의 넓이는 각각 1, 7, 13이 된다. </br>
M, N과 K 그리고 K개의 직사각형의 좌표가 주어질 때, K개의 직사각형 내부를 제외한 나머지 부분이 몇 개의 분리된 영역으로 나누어지는지, </br>
그리고 분리된 각 영역의 넓이가 얼마인지를 구하여 이를 출력하는 프로그램을 작성하시오. </br>

## 입력
첫째 줄에 M과 N, 그리고 K가 빈칸을 사이에 두고 차례로 주어진다. M, N, K는 모두 100 이하의 자연수이다.  </br>
둘째 줄부터 K개의 줄에는 한 줄에 하나씩 직사각형의 왼쪽 아래 꼭짓점의 x, y좌표값과 오른쪽 위 꼭짓점의 x, y좌표값이 빈칸을 사이에 두고 차례로 주어진다. </br>
모눈종이의 왼쪽 아래 꼭짓점의 좌표는 (0,0)이고, 오른쪽 위 꼭짓점의 좌표는(N,M)이다. 입력되는 K개의 직사각형들이 모눈종이 전체를 채우는 경우는 없다. </br>

## 출력
첫째 줄에 분리되어 나누어지는 영역의 개수를 출력한다. 둘째 줄에는 각 영역의 넓이를 오름차순으로 정렬하여 빈칸을 사이에 두고 출력한다. </br>

## 풀이
첫 입력이 모눈종이 형식이라 조금 헷갈렸다. </br>
모눈종이 입력시 끝부부을 한칸씩 줄이면된다. </br>
예를들어 모눈종이로 주어진 (0,2) (0.4) , (1,2) (1,4) 를 꼭짓점으로 가진 직사각형 그래프로 나타내면 </br>
(0,2) (0,3) (1,2) (1,3) 이다. 그래서 반복문으로 뒤쪽 범위만 포함안해주면 된다. </br>
모눈종이의 경우 0,0 이 왼쪽 아래여서 반전이 필요하지만 </br>
이 문제의 경우 영역이 나눠진 수와 그안에 영역 크기만 구하면 됐어서 반전은 안하고 풀었다. </br>

이 이후로는 일반적인 bfs문제이다. </br>
maps를 돌면서 방문안했고 0이면 bfs를 돌리고 영역크기를 추적한다. </br>
하나의 영역이 끝나면 bfs함수를 나와 다음 영역을 찾는다. </br>

```python
import sys
from collections import deque

M, N, K = map(int, input().split())
maps = [[0]*N for _ in range(M)]

dx = [0,0,-1,1]
dy = [-1,1,0,0]
visited = [[False]*N for _ in range(M)]


for i in range(K):
    #print("test")
    l_dot1, l_dot2, r_dot1, r_dot2 = map(int, input().split())    
    
    for y in range(l_dot2,r_dot2):
        for x in range(l_dot1, r_dot1):
            #print(x,y)            
            maps[y][x]=1

#print(maps)

total_count = 0
area = []

def bfs(x,y):
    queue = deque([(x,y)])
    visited[y][x] = True
    count = 0

    while queue:
        x,y = queue.popleft()        

        for i in range(4):
            x1 = x + dx[i]
            y1 = y + dy[i]

            if 0 <= x1 < N and 0 <= y1 < M:
                if maps[y1][x1]==0 and not visited[y1][x1]: 
                    count += 1
                    visited[y1][x1] = True
                    queue.append((x1,y1))                    
    return count

for y in range(M):
    for x in range(N):
        #print(x,y)
        if not visited[y][x] and maps[y][x] == 0:
            #print('start')
            total_count += 1
            cnt = bfs(x,y)            
            area.append(cnt+1)

area.sort()
print(total_count)
print(*area)
```
