# 돌그룹

## 문제
오늘 강호는 돌을 이용해 재미있는 게임을 하려고 한다.  </br>
먼저, 돌은 세 개의 그룹으로 나누어져 있으며 각각의 그룹에는 돌이 A, B, C개가 있다.  </br>
강호는 모든 그룹에 있는 돌의 개수를 같게 만들려고 한다.  </br>
강호는 돌을 단계별로 움직이며, 각 단계는 다음과 같이 이루어져 있다.  </br>
크기가 같지 않은 두 그룹을 고른다. 그 다음, 돌의 개수가 작은 쪽을 X, 큰 쪽을 Y라고 정한다.  </br>
그 다음, X에 있는 돌의 개수를 X+X개로, Y에 있는 돌의 개수를 Y-X개로 만든다.  </br>
A, B, C가 주어졌을 때, 강호가 돌을 같은 개수로 만들 수 있으면 1을, 아니면 0을 출력하는 프로그램을 작성하시오.  </br>

## 입력
첫째 줄에 A, B, C가 주어진다. (1 ≤ A, B, C ≤ 500)  </br>

## 출력
돌을 같은 개수로 만들 수 있으면 1을, 아니면 0을 출력한다.  </br>

## 풀이
bfs를 어떻게 써야할지 몰라서 힌트를 받았다.  </br>
계속 하던 방식이 아니라 처음 방향 잡기가 조금 어려웠다.  </br>

단계별로 움직인다 = 돌을  규칙대로 바꿔주고 바뀐상태에서 다시 진행  </br>
결국 같은 돌을 찾아야한다.  </br>

그래서 조합을 구하는 combinations를 사용하여 3가지로 나올수 있는 조합을 구한다.  </br>
그 다음 나온 조합을 하나씩 bfs 큐에 넣어준다.  </br>
이때 조합을 한번에 다 넣어주고 큐를 돌리기 때문에 bfs가 된다.  </br>

하지만 이렇게 했는데 수가 잘 안맞았다.  </br>
조합을 바로 불러오기보단 인덱스 콤비네이션을 사용해야한다고 한다.  </br>

```python
import sys
from itertools import combinations
from collections import deque

A,B,C = map(int, sys.stdin.readline().split())

def bfs(a,b,c):
  
  queue = deque([(a,b,c)])
  total = a+b+c
  count = 0

  while queue:    
    count += 1
    a,b,c = queue.popleft()
    print(a,b,c)

    arr = [a,b,c]
    combi = list(combinations(arr,2))
    #print('comvi', combi)    

    new_x, new_y = 0,0
    
    for a in combi:
      print('a',a)      
      val1, val2 = a
      
      if val1 >= 0 and val2 >= 0:        

        print('선택 2가지', val1, val2)
        if val1 == val2 == c:
          print('finish!!!!!')
          return 1
        if val1 == val2:
          continue
        if val1 < val2:
          new_x = val1
          new_y = val2
        else:
          new_x = val2
          new_y = val1
        new_x = new_x+new_x
        new_y = new_y-new_x   

        new_c = total - (new_x + new_y)
        if new_c <= 0:
          continue
        print('--',new_x,new_y, new_c,'--')
        queue.append((new_x,new_y,new_c))
        
    if count == 60:
      break

bfs(A,B,C)
   
```

## 풀이2
인덱스로 조합 사용,   </br>
어려운건 아니고 combinations을 구할때 구할 문자열을 넣는것이 아니라   </br>
combinations([0,1,2],2) 이런식으로 0,1,2 의 조합을 구한뒤   </br>
이 조합을 인덱스로 사용하여 구할 문자열에 대입하는 것이다.   </br>
이렇게 하지 않고 위에 처럼 그냥 바로 대입하면  </br>
5 5 10 이런 문자열의 경우 1,2번 인덱스가 구별이 안되어 값이 달라지게 된다.  </br>
그리고 같은 조합의 중복을 방지하기위해  visited를 사용한다.  </br>
이때 1 2 1 과 1 1 2 는 이미 해본 조합이기 때문에 visited넣을때는 tuple에 정렬을해서 넣어준다.

```python
import sys
from itertools import combinations
from collections import deque

A,B,C = map(int, sys.stdin.readline().split())

def bfs(a,b,c):
  
  queue = deque([(a,b,c)])
  visited = {tuple(sorted((a,b,c)))}
  total = a+b+c

  while queue:
    a1,b1,c1 = queue.popleft()
    arr = [a1,b1,c1]
    combi = list(combinations([0,1,2],2))
    #print(combi)    
  
    for com in combi:
      #print('c',com)
      idx1, idx2 = com
      val1, val2 = arr[idx1],arr[idx2]

      if 0 < val1 and 0 < val2:
        x,y = 0,0
        #print('val',val1, val2)

        if val1 < val2:
          x = val1
          y = val2
        if val2 < val1:
          x = val2
          y = val1
        if val1 == val2:
          #print('esle', x, y)
          continue
       
        new_a = x+x
        new_b = y-x
        new_c = total - (new_a + new_b)

        if new_a == new_b == new_c:
          #rint('--finish--')          
          return 1

        new_state = tuple(sorted((new_a,new_b, new_c)))
        #print('visited',visited)
        if new_state not in visited:
          add_state = tuple(sorted((new_a,new_b,new_c)))
          visited.add(add_state)
          queue.append((new_a,new_b,new_c))
          #print('new : ',new_a, new_b, new_c)
 
  return 0
  
result = bfs(A,B,C)
print(result)

```

# 풀이3
위 풀이도 틀렸는데 큐에 넣어줄때 인덱스가 섞이게된다   </br>
val1, val2의 경우 combi로 인덱스 조합을 뽑아 값을 넣어줬는데   </br>
다시 큐로 넣을때는 new_a, new_bm new_c 순으로 고정되어 들어간다.  </br>
3번 인덱스에서 뽑았으면 3번에 넣어줘야 한다.  </br>
+ 시작하자마 같아진 경우 예외 처리를 해줘야하는데 얘를 빼먹었다.  </br>

```python
import sys
from itertools import combinations
from collections import deque

A,B,C = map(int, sys.stdin.readline().split())

def bfs(a,b,c):
  
  queue = deque([(a,b,c)])
  visited = {tuple(sorted((a,b,c)))}
  total = a+b+c

  while queue:
    a1,b1,c1 = queue.popleft()
    arr = [a1,b1,c1]
    combi = list(combinations([0,1,2],2))
    #print(combi)    
    if a1 == b1 == c1:
      return 1
    for com in combi:
      #print('c',com)
      idx1, idx2 = com
      val1, val2 = arr[idx1],arr[idx2]
      new_abc = arr[:]

      if 0 < val1 and 0 < val2:        
        new_a, new_b = 0, 0
        #print('val',val1, val2)
        
        if val1 < val2:         
          new_abc[idx1] = val1 + val1
          new_abc[idx2] = val2 - val1
          new_abc[3-(idx1+idx2)] = total - (val1+val2)
        if val2 < val1: 
          new_abc[idx1] = val2 + val2
          new_abc[idx2] = val1 - val2
          new_abc[3-(idx1+idx2)] = total - (val1+val2)
        if val1 == val2:
          #print('esle', x, y)
          continue
        
        #print('idx',idx1,idx2)
        #print('new',new_abc)        
          
        new_a, new_b, new_c = new_abc

        if new_a == new_b == new_c:
          #print('--finish--')          
          return 1

        new_state = tuple(sorted((new_a,new_b, new_c)))
        #print('visited',visited)
        if new_state not in visited:
          add_state = tuple(sorted((new_a,new_b,new_c)))
          visited.add(add_state)
          queue.append((new_a,new_b,new_c))
          #print('new : ',new_a, new_b, new_c)
 
  return 0
  
result = bfs(A,B,C)
print(result)
```


